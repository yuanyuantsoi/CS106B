/*
 * File: ListCompletions.cpp
 * ---------------------------------------
 *  Problem 4. cell phone reading (H18. Assign3)
 *  The program prints all words from lexicon that 
 *  can be formed by extending the given digit sequence.
 */

#include <iostream>
#include <string>
#include <cctype>
#include "lexicon.h"
#include "strlib.h"
#include "error.h"
using namespace std;

/* Function prototypes */

void listCompletions(string digitSequence, Lexicon & lex);
void recCompletions(string prefix, string rest, Lexicon & lex);
void completePrefix(string prefix, Lexicon & lex);
string digitLetters(char ch);

/* Main program */

int main() {
	Lexicon english("EnglishWords.txt");
	listCompletions("72547", english);
	//listCompletions("72", english);
	return 0;
}

/*
 * Function: listCompletions
 * Usage: listCompletions(digitSequence, lex);
 * ---------------------------------------------------
 *  The function prints all words from the lexicon that 
 *  can be formed by extending the given digit sequence.
 *  The correspondence between digits and letters is the 
 *  same as that on the standard telephone dial.
 *  The implementation at this level is a simple warpper
 *  function that provides the arguments necessary for the
 *  recursive call.
 */
void listCompletions(string digitSequence, Lexicon & lex) {
	cout << "List all the completions of " << digitSequence << endl;
	recCompletions("", digitSequence, lex);
	cout << endl;
}


/*
 * Function: recCompletions
 * Usage: recCompletions(prefix, rest, lex);
 * ----------------------------------------------------------------
 *  The function does all the real work for listCompletions and implements
 *  a more general problem with a recursive solution that is easier to see.
 *  The call to recCompletions generates all words for the digit in the 
 *  string rest prefixed by the mnemonic string in prefix. When the rest string 
 *  is empty, the function call completePrefix to generate the complete words
 *  could be generated by the prefix.
 */
void recCompletions(string prefix, string rest, Lexicon & lex) {
	if (!lex.containsPrefix(prefix)) return;
	if (rest.length() == 0) {
		completePrefix(prefix, lex);
	} else {
		string options = digitLetters(rest[0]);
		for (int i = 0; i < options.size(); i++) {
			recCompletions(prefix + options[i], rest.substr(1), lex);
		}
	}
}

/*
 * Function: completePrefix
 * Usage: completePrefix(prefix, lex);
 * -------------------------------------------------------------------
 *  The function takes a prefix and prints all the words prefixed by
 *  the prefix.
 */
void completePrefix(string prefix, Lexicon & lex) {
	if (!lex.containsPrefix(prefix)) return;
	if (lex.contains(prefix)) cout << toLowerCase(prefix) << endl;
	for (char ch = 'a'; ch <= 'z'; ch++) {
		completePrefix(prefix + ch, lex);
	}
}

/*
 * Function: digitLetters
 * Usage: digitLetters
 * -------------------------------------------------------------------
 *  This function returns a string consisting of the legal substitutions 
 *  for a given digit character. Note that 0 and 1 are handled just by
 *  leaving that digit in its position.
 */
string digitLetters(char ch) {
	switch(ch) {
		case '0': return ("0");
		case '1': return ("1");
		case '2': return ("ABC");
		case '3': return ("DEF");
		case '4': return ("GHI");
		case '5': return ("JKL");
		case '6': return ("MNO");
		case '7': return ("PQRS");
		case '8': return ("TUV");
		case '9': return ("WXYZ");
		default: error("Illegal digit");
	}
}

